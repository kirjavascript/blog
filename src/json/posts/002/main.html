<div class="post pScroll">
    <p>
        I started a rewrite of <a href="http://snk.digibase.ca/flex" target="_blank">an old project</a> recently. When a user loads a binary art file I need a method of drawing the tile data to the screen. 

        Originally, I had been drawing each 8x8 tile as a canvas element. Canvas is great for this kind of thing as it allows you to paint each of the pixels to a single element. However, each tile was drawn to a seperate DOM element because canvas doesn't let you easily manipulate data once it's drawn to the screen. This got really slow when manipulating many tiles at once.
    </p>
    <br />
    <p>
        <div class="one3">
            Here it is in canvas.
            <br />
            <br /><span class="link">Before drawing, each 8x8 tile has been converted to a 64 element array of palette line values.</span>
            <br />
            <br />
            In this example, a reference to the tile is stored so that when the tile is duplicated the image can simply be copied.
        </div>
        <div id="canvas" class="two3"></div>
    </p>
    <p class="clear">
        With canvas, you can use the toDataURL() method to dump a PNG of the container. I wondered if you could use canvas to generate PNG elements of the tiles to use instead to potentially decrease the memory footprint.
        Scratch that, why not just render directly to PNG? 
    </p>
    write post first ->
        gradient fase scroll
        gradient goes beyond the end of the container

js fiddle links for these

            example pic - 
            canvas + cache
            cache png?
            just use png!
    canvas-> PNG

    bow shadow is dark magic

    explain data conversion

draw pixels w/ SVG gradient?
box shadow
PNG - browser prefixes
canvas
divs
full screen container
svg gradient

example in svg
inkscape



<script>
    CodeMirror(document.querySelector("#canvas"), {
        value: `function tile(num,line=0,scale=4) {
    var c = document.createElement('canvas');
    c.width = 8*scale;
    c.height = 8*scale;
    var ctx = c.getContext("2d");

    if(cache.tiles[line][num]) {
        ctx.drawImage(cache.tiles[line][num], 0, 0);
        return c;
    }
    else {
        ctx.scale(scale,scale);

        state.tiles[num].forEach((d,i) => {
            ctx.fillStyle = '#' + state.palettes[line][d];
            let x = 
            ctx.fillRect(i%8,(i/8)|0,1,1)
        })

        cache.tiles[line][num]=c;

        document.body.appendChild(c);
        return c;
    }
}`,
      mode:  "javascript",
      lineNumbers: "true",
      fixedGutter: false,
      lineNumberFormatter: i => i.toString(16).toUpperCase(),
    });

// setTimeout(e => {cm.refresh()},100)
</script>
</div>